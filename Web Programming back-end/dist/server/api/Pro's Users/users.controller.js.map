{"version":3,"sources":["api/Pro's Users/users.controller.js"],"names":["index","show","create","update","destroy","req","res","User","find","populate","exec","then","users","json","catch","err","status","send","findById","params","id","existingUser","message","address","body","user","Address","createdAddress","createdUser","addressLine1","addressLine2","city","state","zip","age","name","firstName","middleName","lastName","all","increment","save","savedObjects","remove","deletedUser"],"mappings":"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","file":"users.controller.js","sourcesContent":["'use strict';\n\nimport {Address, User} from './users.model';\n\n// Find all Users\nexport function index(req, res) {\n  /*\n   The pattern you see below where one function is\n   called right after the other is called method chaining,\n   and is a common practice in JavaScript and many other languages\n   https://en.wikipedia.org/wiki/Method_chaining\n   */\n  User.find()\n    /*\n       For each user object, populate the address attribute.\n       This will make all the attributes available in the address\n       accessible as though the address were a subdocument by joining\n       the two tables for you\n       http://mongoosejs.com/docs/populate.html\n    */\n    .populate('address')\n    /*\n       exec() runs the query and returns a promise object.\n       Promises are a cleaner way to chain asynchronous actions together than\n       callbacks because, instead of nesting functions within functions, you can\n       chain function calls together and pass the return value from one function\n       as the argument to the next! It also allows you to have one method to handle\n       exceptions, instead of having to provide them in each callback function you write\n       http://www.javascriptkit.com/javatutors/javascriptpromises.shtml\n       http://bluebirdjs.com/docs/why-promises.html\n    */\n    .exec()\n    // This then method will only be called if the query was successful, so no need to error check!\n    .then(function(users) {\n      res.json({\n        users\n      });\n    })\n    /*\n     Any errors encountered here must be server side, since there are no arguments to the find\n     Return 500 (server error) and send the error encountered back to the requester\n    */\n    .catch(function(err) {\n      res.status(500);\n      res.send(err);\n    });\n}\n\n// Find details for one user\nexport function show(req, res) {\n  User.findById(req.params.id)\n    .populate('address')\n    .exec()\n    .then(function(existingUser) {\n      /*\n       findById will return null if the object was not found\n       This if check will evaluate to false for a null user\n      */\n      if(existingUser) {\n        // User was found by Id\n        res.status(200);\n        res.json(existingUser);\n      } else {\n        // User was not found\n        res.status(404);\n        res.json({message: 'Not Found'});\n      }\n    })\n    .catch(function(err) {\n      res.status(400);\n      res.send(err);\n    });\n}\n\n// Create a new user\nexport function create(req, res) {\n  /*\n    In this function we are taking the request body\n    As it was sent and using it as the JSON for the address\n    and user objects.\n    Since address is stored in a separate collection from user\n    we must create each document individually, and then associate\n    the address to the user after we know its id\n  */\n  let address = req.body.address;\n  let user = req.body;\n  // Start off by saving the address\n  Address.create(address)\n    /*\n     Address was successfully saved, now associate saved address to the\n     user we are about to create and then save the user\n    */\n    .then(function(createdAddress) {\n      user.address = createdAddress;\n      /*\n       This return statement will return a promise object.\n       That means that the following .then in this chain\n       will not occur until after the user is saved, and will be given the result\n       of this promise resolving, which is the created user object\n      */\n      return User.create(user);\n    })\n    // User and Address saved successfully! return 201 with the created user object\n    .then(function(createdUser) {\n      res.status(201);\n      res.json(createdUser);\n    })\n    // An error was encountered during either the save of the address or the save of the user\n    .catch(function(err) {\n      res.status(400);\n      res.send(err);\n    });\n}\n\n// Update a user\nexport function update(req, res) {\n  // Start by trying to find the user by its id\n  User.findById(req.params.id)\n    .populate('address')\n    .exec()\n    // Update user and address\n    .then(function(existingUser) {\n      // If user exists, update all fields of the object\n      if(existingUser) {\n        existingUser.address.addressLine1 = req.body.address.addressLine1;\n        existingUser.address.addressLine2 = req.body.address.addressLine2;\n        existingUser.address.city = req.body.address.city;\n        existingUser.address.state = req.body.address.state;\n        existingUser.address.zip = req.body.address.zip;\n        existingUser.age = req.body.age;\n        existingUser.name.firstName = req.body.name.firstName;\n        existingUser.name.middleName = req.body.name.middleName;\n        existingUser.name.lastName = req.body.name.lastName;\n        /*\n         Promise.all takes an array of promises as an argument\n         It ensures that all the promises in the array have successfully resolved before\n         continuing the promise chain. It will pass to the next .then an array of results, one\n         for each promise that was passed\n        */\n        return Promise.all([\n          existingUser.address.increment().save(),\n          existingUser.increment().save()\n        ]);\n      } else {\n        // User was not found\n        return existingUser;\n      }\n    })\n    // This .then will be called after the Promise.all resolves, or be called with null if the user was not found\n    .then(function(savedObjects) {\n      // savedObjects should be defined if Promise.all was invoked (user was found)\n      if(savedObjects) {\n        res.status(200);\n        // The order of responses are guaranteed to be the same as the order of the promises, so we can assume\n        // the second element of the array is the result of the user update\n        res.json(savedObjects[1]);\n      } else {\n        // User was not found\n        res.status(404);\n        res.json({message: 'Not Found'});\n      }\n    })\n    // Error encountered during the save of the user or address\n    .catch(function(err) {\n      res.status(400);\n      res.send(err);\n    });\n}\n\n// Remove a user\nexport function destroy(req, res) {\n  User.findById(req.params.id)\n    .populate('address')\n    .exec()\n    .then(function(existingUser) {\n      if(existingUser) {\n        /*\n          This is the equivalent of cascading delete in a relational database\n          If the user was found, remove both the user object and the address object from\n          their respective collections. Only record the delete as successful if both objects\n          are deleted\n         */\n        return Promise.all([\n          existingUser.address.remove(),\n          existingUser.remove()\n        ]);\n      } else {\n        return existingUser;\n      }\n    })\n    // Delete was successful\n    .then(function(deletedUser) {\n      if(deletedUser) {\n        res.status(204).send();\n      } else {\n        // User was not found\n        res.status(404);\n        res.json({message: 'Not Found'});\n      }\n    })\n    // Address or user delete failed\n    .catch(function(err) {\n      res.status(400);\n      res.send(err);\n    });\n}\n\n"]}