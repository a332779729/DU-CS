{"version":3,"sources":["api/recipes/recipes.controller.js"],"names":["index","show","create","update","destroy","req","res","Recipe","find","populate","exec","then","recipes","json","catch","err","status","send","findById","params","id","existingRecipe","message","recipe","body","createdRecipe","console","log","name","description","pictureURL","prepTime","cookingTime","directions","ingredients","nutrition","poison","all","increment","save","savedObjects","remove","deletedRecipe"],"mappings":"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","file":"recipes.controller.js","sourcesContent":["'use strict';\n\nimport {Recipe} from './recipes.model';\n\n/**\n* Find all Recipes\n*/\nexport function index(req, res) {\n  Recipe.find()\n    .populate('userReviews')\n    .exec()\n    // This then method will only be called if the query was successful, so no need to error check!\n    .then(function(recipes) {\n      res.json({\n        recipes\n      });\n    })\n    .catch(function(err) {\n      res.status(500);\n      res.send(err);\n    });\n}\n\n\n\n/**\n* Find review details by recipe Id\n* @param {String} id : recipe Id\n*/\nexport function show(req, res) {\n  Recipe.findById(req.params.id)\n    .populate('userReviews')\n    .exec()\n    .then(function(existingRecipe) {\n      /*\n       findById will return null if the object was not found\n       This if check will evaluate to false for a null recipe\n      */\n      if(existingRecipe) {\n        // Recipe was found by Id\n        res.status(200);\n        res.json(existingRecipe);\n      } else {\n        // Recipe was not found\n        res.status(404);\n        res.json({message: 'Not Found'});\n      }\n    })\n    .catch(function(err) {\n      res.status(400);\n      res.send(err);\n    });\n}\n\n\n\n/**\n* Create a new Recipe\n* @param {String} name : Name of recipe\n* @param {String} description : Description of recipe\n* @param {String} pictureURL : Picture URL for recipe\n* @param {Number} prepTime : Prep time (minutes)\n* @param {Number} cookingTime : Cooking time (minutes)\n* @param {String} directions : Array of directions (i.e. step by step directions)\n* @param {Object} ingredients : Array of ingredients\n    {\n      @param {String} nutrition, nutrition\n      @param {String} poison poison\n    }\n*/\nexport async function create(req, res) {\n  /*\n    In this function we are taking the request body\n    As it was sent and using it as the JSON for the address\n    and recipe objects.\n    Since address is stored in a separate collection from recipe\n    we must create each document individually, and then associate\n    the address to the recipe after we know its id\n  */\n  let recipe = req.body;\n\n  //Exceeding basic requirements\n  //i used the async/await function\n  try{\n    let createdRecipe = await Recipe.create(recipe);\n\n    res.status(201);\n    res.json(createdRecipe);\n\n  }catch(err){\n    //console.log(err);\n    res.status(400);\n    res.send(err);\n  }\n\n}\n\n\n\n/**\n* Update a recipe\n* @param {String} id : Recipe ID\n* @param {String} name : Name of recipe\n* @param {String} description : Description of recipe\n* @param {String} pictureURL : Picture URL for recipe\n* @param {Number} prepTime : Prep time (minutes)\n* @param {Number} cookingTime : Cooking time (minutes)\n* @param {String} directions : Array of directions (i.e. step by step directions)\n* @param {Object} ingredients : Array of ingredients\n* @param {Object} ingredients : Array of ingredients\n    {\n      @param {String} nutrition, nutrition\n      @param {String} poison poison\n    }\n*/\nexport function update(req, res) {\n  // Start by trying to find the recipe by its id\n  Recipe.findById(req.params.id)\n    .exec()\n    // Update recipe and address\n    .then(function(existingRecipe) {\n      // If recipe exists, update all fields of the object\n      console.log(existingRecipe);\n      if(existingRecipe) {\n        existingRecipe.name = req.body.name;\n        existingRecipe.description = req.body.description;\n        existingRecipe.pictureURL = req.body.pictureURL;\n        existingRecipe.prepTime = req.body.prepTime;\n        existingRecipe.cookingTime = req.body.cookingTime;\n        existingRecipe.directions = req.body.directions;\n        existingRecipe.ingredients.nutrition = req.body.ingredients.nutrition;\n        existingRecipe.ingredients.poison = req.body.ingredients.poison;\n        //existingRecipe.userReviews = req.body.userReviews;\n        /*\n         Promise.all takes an array of promises as an argument\n         It ensures that all the promises in the array have successfully resolved before\n         continuing the promise chain. It will pass to the next .then an array of results, one\n         for each promise that was passed\n        */\n        return Promise.all([\n          existingRecipe.increment().save()\n        ]);\n      } else {\n        // Recipe was not found\n        return existingRecipe;\n      }\n    })\n    // This .then will be called after the Promise.all resolves, or be called with null if the recipe was not found\n    .then(function(savedObjects) {\n      // savedObjects should be defined if Promise.all was invoked (recipe was found)\n      if(savedObjects) {\n        res.status(200);\n        // The order of responses are guaranteed to be the same as the order of the promises, so we can assume\n        // the second element of the array is the result of the recipe update\n        res.json(savedObjects[1]);\n      } else {\n        // Recipe was not found\n        res.status(404);\n        res.json({message: 'Not Found'});\n      }\n    })\n    // Error encountered during the save of the recipe\n    .catch(function(err) {\n      console.log(err);\n      res.status(400);\n      res.send(err);\n    });\n}\n\n\n\n/**\n* Remove a recipe\n* @param {String} id : Recipe ID\n*/\nexport function destroy(req, res) {\n  Recipe.findById(req.params.id)\n    .exec()\n    .then(function(existingRecipe) {\n      if(existingRecipe) {\n        /*\n          This is the equivalent of cascading delete in a relational database\n          If the recipe was found, remove both the recipe object and the address object from\n          their respective collections. Only record the delete as successful if both objects\n          are deleted\n         */\n        return Promise.all([\n          existingRecipe.remove()\n        ]);\n      } else {\n        return existingRecipe;\n      }\n    })\n    // Delete was successful\n    .then(function(deletedRecipe) {\n      if(deletedRecipe) {\n        res.status(204).send();\n      } else {\n        // Recipe was not found\n        res.status(404);\n        res.json({message: 'Not Found'});\n      }\n    })\n    // Recipe delete failed\n    .catch(function(err) {\n      res.status(400);\n      res.send(err);\n    });\n}\n"]}